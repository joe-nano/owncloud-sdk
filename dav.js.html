<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dav.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dav.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { createClient } = require('webdav')
const parser = require('./xmlParser.js')

const applicationXmlResponseHeaders = {
  'Content-Type': 'application/xml; charset=utf-8'
}
export class Dav {
  constructor (baseUrl) {
    this._XML_CHAR_MAP = {
      '&lt;': '&amp;lt;',
      '>': '&amp;gt;',
      '&amp;': '&amp;amp;',
      '"': '&amp;quot;',
      "'": '&amp;apos;'
    }

    this.baseUrl = baseUrl

    this.userName = null

    this.password = null

    this.xmlNamespaces = {
      'DAV:': 'd',
      'http://owncloud.org/ns': 'oc'
    }

    this.xmlNamespacesComponents = {
      d: 'DAV:',
      oc: 'http://owncloud.org/ns'
    }

    this.client = createClient(baseUrl, {})
  }

  _escapeXml (s) {
    return s.replace(/[&lt;>&amp;"']/g, function (ch) {
      return this._XML_CHAR_MAP[ch]
    })
  };

  /**
   * Generates a propFind request.
   *
   * @param {string} url Url to do the propfind request on
   * @param {Array} properties List of properties to retrieve.
   * @param {string} depth "0", "1" or "infinity"
   * @param {Object} [headers] headers
   * @return {Promise}
   */
  propFind (path, properties, depth = '0', headers = {}, options = {}) {
    // depth header must be a string, in case a number was passed in
    depth = '' + depth

    headers = headers || {}

    headers = { ...headers, Depth: depth, ...applicationXmlResponseHeaders }

    var body =
          '&lt;?xml version="1.0"?>\n' +
          '&lt;d:propfind '
    var namespace
    for (namespace in this.xmlNamespaces) {
      body += ' xmlns:' + this.xmlNamespaces[namespace] + '="' + namespace + '"'
    }
    body += '>\n' +
          '  &lt;d:prop>\n'

    for (var ii in properties) {
      if (!Object.hasOwnProperty.call(properties, ii)) {
        continue
      }

      var property = this.parseClarkNotation(properties[ii])
      if (this.xmlNamespaces[property.namespace]) {
        body += '    &lt;' + this.xmlNamespaces[property.namespace] + ':' + property.name + ' />\n'
      } else {
        body += '    &lt;x:' + property.name + ' xmlns:x="' + property.namespace + '" />\n'
      }
    }
    body += '  &lt;/d:prop>\n'
    body += '&lt;/d:propfind>'

    return this.request('PROPFIND', path, headers, body, options).then(
      function (result) {
        const body = depth === '0' ? result.body[0] : result.body
        return {
          status: result.status,
          body,
          res: result
        }
      }
    )
  }

  /**
   * Renders a "d:set" block for the given properties.
   *
   * @param {Object.&lt;String,String>} properties
   * @return {String} XML "&lt;d:set>" block
   */
  _renderPropSet (properties) {
    var body = '  &lt;d:set>\n' +
          '   &lt;d:prop>\n'

    for (var ii in properties) {
      if (!Object.hasOwnProperty.call(properties, ii)) {
        continue
      }

      var property = this.parseClarkNotation(ii)
      var propName
      var propValue = properties[ii]
      if (this.xmlNamespaces[property.namespace]) {
        propName = this.xmlNamespaces[property.namespace] + ':' + property.name
      } else {
        propName = 'x:' + property.name + ' xmlns:x="' + property.namespace + '"'
      }

      // FIXME: hard-coded for now until we allow properties to
      // specify whether to be escaped or not
      if (propName !== 'd:resourcetype') {
        propValue = this._escapeXml(propValue)
      }
      body += '      &lt;' + propName + '>' + propValue + '&lt;/' + propName + '>\n'
    }
    body += '    &lt;/d:prop>\n'
    body += '  &lt;/d:set>\n'
    return body
  }

  /**
   * Generates a propPatch request.
   *
   * @param {string} url Url to do the proppatch request on
   * @param {Object.&lt;String,String>} properties List of properties to store.
   * @param {Object} [headers] headers
   * @return {Promise}
   */
  propPatch (url, properties, headers) {
    headers = headers || {}

    headers = { ...headers, ...applicationXmlResponseHeaders }

    var body =
          '&lt;?xml version="1.0"?>\n' +
          '&lt;d:propertyupdate '
    var namespace
    for (namespace in this.xmlNamespaces) {
      body += ' xmlns:' + this.xmlNamespaces[namespace] + '="' + namespace + '"'
    }
    body += '>\n' + this._renderPropSet(properties)
    body += '&lt;/d:propertyupdate>'

    return this.request('PROPPATCH', url, headers, body).then(
      function (result) {
        return {
          status: result.status,
          body: result.body,
          res: result
        }
      }
    )
  }

  /**
   * Generates a MKCOL request.
   * If attributes are given, it will use an extended MKCOL request.
   *
   * @param {string} url Url to do the proppatch request on
   * @param {Object.&lt;String,String>} [properties] list of properties to store.
   * @param {Object} [headers] headers
   * @return {Promise}
   */
  mkcol (url, properties, headers) {
    var body = ''
    headers = headers || {}
    headers['Content-Type'] = 'application/xml; charset=utf-8'

    if (properties) {
      body =
              '&lt;?xml version="1.0"?>\n' +
              '&lt;d:mkcol'
      var namespace
      for (namespace in this.xmlNamespaces) {
        body += ' xmlns:' + this.xmlNamespaces[namespace] + '="' + namespace + '"'
      }
      body += '>\n' + this._renderPropSet(properties)
      body += '&lt;/d:mkcol>'
    }

    return this.request('MKCOL', url, headers, body).then(
      function (result) {
        return {
          status: result.status,
          body: result.body,
          res: result
        }
      }
    )
  }

  /**
   * Performs a HTTP request, and returns a Promise
   *
   * @param {string} method HTTP method
   * @param {string} path Relative or absolute url
   * @param {Object} headers HTTP headers as an object.
   * @param {string} body HTTP request body.
   * @param {Object} options
   * @param {Function} options.onProgress progress callback
   * @return {Promise}
   */
  request (method, path, headers, body, options = {}) {
    const reqClient = this.client
    const reqBaseUrl = this.baseUrl

    const params = new URLSearchParams(options.query).toString()
    const query = params ? '?' + params : ''
    delete options.query

    const requestOptions = {
      url: reqBaseUrl + path + query,
      method,
      headers,
      data: body,
      ...options
    }
    return new Promise((resolve) => {
      return reqClient.customRequest('', requestOptions)
        .then(res => {
          var resultBody = res.data
          if (res.status === 207) {
            resultBody = this.parseMultiStatus(resultBody)
          }
          resolve({
            body: resultBody,
            status: res.status,
            res
          })
        }).catch(error => {
          const res = error.response

          resolve({
            body: res?.data,
            status: res?.status,
            res
          })
        })
    })
  }

  /**
   * Parses a property node.
   *
   * Either returns a string if the node only contains text, or returns an
   * array of non-text subnodes.
   *
   * @param {Object} propNode node to parse
   * @return {string|Array} text content as string or array of subnodes, excluding text nodes
   */
  _parsePropNode (propNode) {
    var content = null
    if (propNode.constructor === Object) {
      if (Object.keys(propNode).length === 0) {
        return ''
      }
      var subNodes = []
      // Propnode can be any one of these
      //         { 'oc:share-type': [ '0', '3' ] }
      //         { 'oc:share-type': '3' }
      //         { 'd:collection': {} }
      for (var key in propNode) {
        var node = propNode[key]
        if (typeof node !== 'object') {
          subNodes.push(node)
          continue
        }
        if (Array.isArray(node)) {
          for (var item of node) {
            subNodes.push(item)
          }
          continue
        }
        var nsComponent = key.split(':')[0]
        var localComponent = key.split(':')[1]
        var nsValue = this.xmlNamespacesComponents[nsComponent]
        subNodes.push('{' + nsValue + '}' + localComponent)
      }
      if (subNodes.length) {
        content = subNodes
      }
    } else if (propNode) {
      content = propNode
    } else {
      content = ''
    }

    return content
  }

  /**
   * Parses a multi-status response body.
   *
   * @param {string} xmlBody
   */
  parseMultiStatus (xmlBody) {
    const doc = parser.xml2js(xmlBody)

    var responseIterator = doc['d:multistatus']['d:response'] || []
    if (responseIterator.constructor !== Array) {
      responseIterator = [responseIterator]
    }
    var result = []
    responseIterator.forEach(responseNode => {
      var response = {
        href: null,
        propStat: []
      }

      response.href = responseNode['d:href']

      var propStatIterator = responseNode['d:propstat']

      if (propStatIterator.constructor !== Array) {
        propStatIterator = [propStatIterator]
      }
      propStatIterator.forEach(propStatNode => {
        var propStat = {
          status: propStatNode['d:status'],
          properties: {}
        }

        var propIterator = propStatNode['d:prop']
        if (propIterator.constructor !== Array) {
          propIterator = [propIterator]
        }
        propIterator.forEach(propNode => {
          for (var key in propNode) {
            var content = this._parsePropNode(propNode[key])
            var nsComponent = key.split(':')[0]
            var localComponent = key.split(':')[1]
            var nsValue = this.xmlNamespacesComponents[nsComponent]
            propStat.properties['{' + nsValue + '}' + localComponent] = content
          }
        })
        response.propStat.push(propStat)
      })

      result.push(response)
    })
    return result
  }

  parseClarkNotation (propertyName) {
    var result = propertyName.match(/^{([^}]+)}(.*)$/)
    if (!result) {
      return
    }

    return {
      name: result[2],
      namespace: result[1]
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Apps.html">Apps</a></li><li><a href="FileInfo.html">FileInfo</a></li><li><a href="Files.html">Files</a></li><li><a href="FilesTrash.html">FilesTrash</a></li><li><a href="FilesVersions.html">FilesVersions</a></li><li><a href="Groups.html">Groups</a></li><li><a href="HttpError.html">HttpError</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="ownCloud.html">ownCloud</a></li><li><a href="PublicFiles.html">PublicFiles</a></li><li><a href="Settings.html">Settings</a></li><li><a href="ShareInfo.html">ShareInfo</a></li><li><a href="Shares.html">Shares</a></li><li><a href="SystemTags.html">SystemTags</a></li><li><a href="Users.html">Users</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createHashedKey">createHashedKey</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Wed May 25 2022 09:20:19 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
